**Задача 1:**

#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>

int main() {
  int n = 0;
  std::cout << "Введите высоту: ";
  std::cin >> n;
  std::srand(std::time(0)); //для рандома
  std::vector<std::vector<int>> pyramid; //создаем пирамиду

  for (int i = 0; i < n; i = i + 1) { //заполняем пирамиду рандомными значениями
    std::vector<int> row(i + 1);
    for (int j = 0; j <= i; j = j + 1) {
      row[j] = std::rand() % 100;
    }
    pyramid.push_back(row);
  }

  for (int i = 0; i < n; i = i + 1) { //выводим пирамиду
    for (int j = 0; j <= i; j = j + 1) {
      std::cout << pyramid[i][j] << " ";
    }
    std::cout << std::endl;
  }

  std::vector<std::vector<int>> dp = pyramid; //копируем пирамиду
  for (int i = n - 2; i >= 0; i = i - 1) { //используем dp для заполнения снизу вверх, вверху будет наш минимум
    for (int j = 0; j <= i; j = j + 1) {
      dp[i][j] += std::min(dp[i + 1][j], dp[i + 1][j + 1]);
    }
  }

  int min_sum = dp[0][0];
  std::cout << "Минимальная сумма: " << min_sum << std::endl;
  std::vector<int> path; //для хранения пути
  path.push_back(pyramid[0][0]);
  int column = 0; //стобец в пирамие
  for (int i = 1; i < n; i = i + 1) { //ищем разницу значений в dp и в пирамиде, так мы найдем нижнего соседа
    if (dp[i - 1][column] - pyramid[i - 1][column] == dp[i][column]) {
      path.push_back(pyramid[i][column]);
    } else {
      column = column + 1;
      path.push_back(pyramid[i][column]);
    }
  }
  std::cout << "Путь: ";
  for (size_t i = 0; i < path.size(); i = i + 1) {
    std::cout << path[i] << " ";
  }
  return 0;
}

**Задача 2:**

#include <iostream>
#include <vector>

//используем поиск в глубину, посещаем вешину и смотрим ее соседей, если они не поещены, то вызываем dfs оттуда
void dfs(int v, std::vector<bool>& visited, std::vector<std::vector<int>>& graph) {
  visited[v] = true;
  for (int u : graph[v]) {
    if (!visited[u]) {
      dfs(u, visited, graph);
    }
  }
}

int main() {
  int n = 0;
  int m = 0;
  int components = 0;
  std::cin >> n >> m;
  std::vector<std::vector<int>> graph(n + 1); //список смежности
  std::vector<bool> visited(n + 1, false); //посещена вершина или нет

  for (int i = 0; i < m; i = i + 1) { //создаем список смежности
    int u = 0;
    int v = 0;
    std::cin >> u >> v;
    graph[u].push_back(v);
    graph[v].push_back(u);
  }

//смотрим посещена вершина или нет, если нет, то +1 к комонентам и запускаем dfs
  for (int i = 1; i <= n; i = i + 1) {
    if (!visited[i]) {
      dfs(i, visited, graph);
      components = components + 1;
    }
  }
    
  std::cout << components - 1;
  return 0;
}

**Задача 3:**

#include <iostream>

int main() {
  int n = 0;
  int k = 0;
  int command = 0;
  int first_value = 0;
  int second_value = 0;
  int* sum_arr = new int[k];
  int position_arr = 0;
  std::cin >> n >> k;
  int* amount_precipitation = new int[n]; //массив для хранения снега

//обрабатываем событие, если 1 - доавляем снег, если 2 - заносим сумму в массив, чтобы в конце вывести
  for (int i = 0; i < k; i = i + 1) {
    std::cin >> command;
    if (command == 1) {
      std::cin >> first_value >> second_value;
      amount_precipitation[first_value - 1] += second_value;
    } else {
      int sum = 0;
      std::cin >> first_value >> second_value;
      for (int j = first_value - 1; j < second_value; j = j + 1) {
        sum = sum + amount_precipitation[j];
      }
      sum_arr[position_arr] = sum;
      position_arr = position_arr + 1;
    }
  }

//выводим все наши запросы (2)
  for (int i = 0; i < position_arr; i = i + 1) {
    std::cout << sum_arr[i] << std::endl;
  }

//чистим память
  delete[] amount_precipitation;
  delete[] sum_arr;
  return 0;
}
